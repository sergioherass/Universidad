/*-
 * main.c
 * Minishell C source
 * Shows how to use "obtain_order" input interface function.
 *
 * Copyright (c) 1993-2002-2019, Francisco Rosales <frosal@fi.upm.es>
 * Todos los derechos reservados.
 *
 * Publicado bajo Licencia de Proyecto Educativo Pr치ctico
 * <http://laurel.datsi.fi.upm.es/~ssoo/LICENCIA/LPEP>
 *
 * Queda prohibida la difusi칩n total o parcial por cualquier
 * medio del material entregado al alumno para la realizaci칩n
 * de este proyecto o de cualquier material derivado de este,
 * incluyendo la soluci칩n particular que desarrolle el alumno.
 *
 * DO NOT MODIFY ANYTHING OVER THIS LINE
 * THIS FILE IS TO BE MODIFIED
 */

#include <stddef.h>			/* NULL */
#include <stdio.h>			/* setbuf, printf */
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/times.h>
#include <sys/wait.h>
#include <time.h>
#include <fcntl.h>

extern int obtain_order();		/* See parser.y for description */

int main(void)
{
	char ***argvv = NULL;
	int argvc;
	char **argv = NULL;
	//int argc;
	char *filev[3] = { NULL, NULL, NULL };
	int bg;
	int ret;
	//int fdin;
	int fdout;
	//int fderr;
	int tub[2];
	int salida;
    struct sigaction act;
	struct sigaction act2;

	setbuf(stdout, NULL);			/* Unbuffered */
	setbuf(stdin, NULL);

	act.sa_handler=SIG_IGN;
	act.sa_flags=0;
	sigaction(SIGINT,&act,NULL);
	act2.sa_handler=SIG_IGN;
    act2.sa_flags=0;
	sigaction(SIGQUIT,&act2,NULL);

	while (1) {
		fprintf(stderr, "%s", "msh> ");	/* Prompt */
		ret = obtain_order(&argvv, filev, &bg);
		if (ret == 0) break;		/* EOF */
		if (ret == -1) continue;	/* Syntax error */
		argvc = ret - 1;		/* Line */
		if (argvc == 0) continue;	/* Empty line */
#if 1
/*
 * LAS LINEAS QUE A CONTINUACION SE PRESENTAN SON SOLO
 * PARA DAR UNA IDEA DE COMO UTILIZAR LAS ESTRUCTURAS
 * argvv Y filev. ESTAS LINEAS DEBERAN SER ELIMINADAS.
 */

		for (argvc = 0; (argv = argvv[argvc]); argvc++) { 

			 if (argvv[argvc+1]!=NULL){
				if(pipe(tub)<0){
					perror("error al crear tuberia");
					exit(1);
				}
			 }
			 /*if(!bg){
				act.sa_handler=SIG_DFL;
                act.sa_flags=0;
        		sigaction(SIGINT,&act,NULL);
        		act2.sa_handler=SIG_DFL;
        		act2.sa_flags=0;
        		sigaction(SIGQUIT,&act2,NULL);
			 }*/
             if(bg){
				act.sa_handler=SIG_IGN;
                act.sa_flags=0;
        		sigaction(SIGINT,&act,NULL);
        		act2.sa_handler=SIG_IGN;
        		act2.sa_flags=0;
        		sigaction(SIGQUIT,&act2,NULL);

			 } 



			 if(strcmp(argvv[0][0],"cd")==0){
				
		        char *new_dir=argvv[0][1];
		   		char actual_dir[PATH_MAX];
		
                if (filev[1]) {
                    fdout=creat(filev[1],0666);
                    if(fdout==-1){
                        perror("Error al abrir el archivo de salida");
                        exit(1);
                    }
				    if(new_dir==NULL){
					    new_dir=getenv("HOME");
					    if(new_dir==NULL){
			  			     fprintf(stderr,"Error:No se pudo obtener el directorio HOME.\n");
							 //exit(1);
			  			     //continue;
					    }
		   		    }
				    if(strcmp(new_dir,".")==0){
						dprintf(fdout,"%s\n",getenv("HOME"));break;
					}else{
						if(chdir(new_dir)!=0){
							perror("Error al cambiar de directorio");
							//exit(1);
						}
						if(getcwd(actual_dir,sizeof(actual_dir))==NULL){
							perror("Error al obtener el directorio actual");
							//exit(1);
						}else{
							dprintf(fdout,"%s\n",actual_dir);
							break;
						}
						//dup2(fdout,1);
						//dprintf(fdout,getcwd(actual_dir,sizeof(actual_dir)));
						close(fdout);
					}
                }
				if (argvv[0][2]!=NULL){
					fprintf(stderr,"Error: numero incorrecto de argumentos\n");
					break;
				}
		   		if(new_dir==NULL){
					new_dir=getenv("HOME");
					if(new_dir==NULL){
			  			fprintf(stderr,"Error:No se pudo obtener el directorio HOME.\n");
						exit(1);
			  			//continue;
					}
		   		}
				if(strcmp(new_dir,".")==0){
						printf("%s\n",getenv("HOME"));break;
				}else{
					if(chdir(new_dir)!=0){
						perror("Error al cambiar de directorio");
						//exit(1);
						//continue;
					}
					if(getcwd(actual_dir,sizeof(actual_dir))==NULL){
						perror("Error al obtener el directorio actual");
						//exit(1);
					}else{
						printf("%s\n",actual_dir);
						//break;
					}
				}


			 } if(strcmp(argvv[0][0],"umask")==0){
                   		   mode_t old_mask=umask(0);
                   		   umask(old_mask); 
                    if(argvv[0][2]!=NULL){
                        fprintf(stderr,"umask: numero incorrecto de argumentos\n");
						break;
						//exit(1);
                   	}
                    if (filev[1]) {
                        fdout=creat(filev[1],0666);
                        if(fdout==-1){
                            perror("error al abrir el archivo de salida");
                            exit(1);
                        }
						if (argvv[0][1]==NULL){
				   			//printf("%o\n",old_mask);
							dprintf(fdout,"%d",old_mask);
				   		}
                   		if(argvv[0][1]!=NULL){
                      		char *endptr;
                      		long new_mask=strtol(argv[1],&endptr,8);
                      		if(*endptr=='\0'){
                         		umask((mode_t)new_mask);
                     		}else{
                        		fprintf(stderr,"umask:valor octal invalido: %s\n",argv[1]);
								//exit(1);
                      		}
                   	    } 
				   		/*if(argvv[0][2]!=NULL){
                          	fprintf(stderr,"umask: mayor numero de argumentos\n");
							break;
							//exit(1);
                   		}*/

                   //continue;
                    //dup2(fdout,1);
                    close(fdout);
					break;
                 }
                                        
				   if (argvv[0][1]==NULL){
				   	printf("%o\n",old_mask);
				   }
                   if(argvv[0][1]!=NULL){
                      			char *endptr;
                      			long new_mask=strtol(argv[1],&endptr,8);
                      			if(*endptr=='\0'){
                         			umask((mode_t)new_mask);
                     			}else{
                        			fprintf(stderr,"umask:valor octal invalido: %s\n",argv[1]);
									//exit(1);
                      			}
                   	} 
				   /*if(argvv[0][2]!=NULL){
                        fprintf(stderr,"umask: numero incorrecto de argumentos\n");
						break;
						//exit(1);
                   	}*/

                   continue;
                }
				if (strcmp(argv[0], "time") == 0) {
					struct tms tmsbuf;
                    clock_t start = times(&tmsbuf);
                    //clock_t end = times(&tmsbuf);
    				if (argvv[0][1]==NULL) {
						if (filev[1]) {
								fdout=creat(filev[1],0666);
									if(fdout==-1){
										perror("error al abrir el archivo de salida");
										exit(1);
									}
									//dup2(fdout,1);
									//int status;
            						//waitpid(pid, &status, 0);
            						clock_t end = times(&tmsbuf);

            						long ticks_per_second = sysconf(_SC_CLK_TCK);
                    				double user_time = (double)tmsbuf.tms_cutime / ticks_per_second;
                    				double system_time = (double)tmsbuf.tms_cstime / ticks_per_second;
                    				double real_time = (double)(end - start) / ticks_per_second;

                    				dprintf(fdout,"%d.%03du %d.%03ds %d.%03dr\n",
                    				(int)user_time, (int)(user_time * 1000) % 1000,
                    				(int)system_time, (int)(system_time * 1000) % 1000,
                    				(int)real_time, (int)(real_time * 1000) % 1000);

									close(fdout);
									break;
							}else{
        		    			struct tms tmsbuf;
                    			clock_t start = times(&tmsbuf);
                    			clock_t end = times(&tmsbuf);

       			    			long ticks_per_second = sysconf(_SC_CLK_TCK);
                    			double user_time = (double)tmsbuf.tms_utime / ticks_per_second;
                    			double system_time = (double)tmsbuf.tms_stime / ticks_per_second;
                    			double real_time = (double)(end - start) / ticks_per_second;

                    			printf("%d.%03du %d.%03ds %d.%03dr\n",
                    			(int)user_time, (int)(user_time * 1000) % 1000,
                    			(int)system_time, (int)(system_time * 1000) % 1000,
                    			(int)real_time, (int)(real_time * 1000) % 1000);
							}

    				} else {
                  		pid_t pid;
        	  	  		struct tms tmsbuf;
                  		clock_t end;

                  		clock_t start = times(&tmsbuf);
                  		pid = fork();

                  		if (pid == 0) {

                        	if (execvp(argv[1], &argv[1]) == -1) {
                			perror("Error al ejecutar el comando");
                			exit(1);

            				}
        	  	  		} else if (pid > 0) {
							if (filev[1]) {
								fdout=creat(filev[1],0666);
									if(fdout==-1){
										perror("error al abrir el archivo de salida");
										exit(1);
									}
									//dup2(fdout,1);
									int status;
            						waitpid(pid, &status, 0);
            						end = times(&tmsbuf);

            						long ticks_per_second = sysconf(_SC_CLK_TCK);
                    				double user_time = (double)tmsbuf.tms_cutime / ticks_per_second;
                    				double system_time = (double)tmsbuf.tms_cstime / ticks_per_second;
                    				double real_time = (double)(end - start) / ticks_per_second;

                    				dprintf(fdout,"%d.%03du %d.%03ds %d.%03dr\n",
                    				(int)user_time, (int)(user_time * 1000) % 1000,
                    				(int)system_time, (int)(system_time * 1000) % 1000,
                    				(int)real_time, (int)(real_time * 1000) % 1000);

									close(fdout);
									break;
							}else{
                   				int status;
            					waitpid(pid, &status, 0);
            					end = times(&tmsbuf);

            					long ticks_per_second = sysconf(_SC_CLK_TCK);
                    			double user_time = (double)tmsbuf.tms_cutime / ticks_per_second;
                    			double system_time = (double)tmsbuf.tms_cstime / ticks_per_second;
                    			double real_time = (double)(end - start) / ticks_per_second;

                    			printf("%d.%03du %d.%03ds %d.%03dr\n",
                    			(int)user_time, (int)(user_time * 1000) % 1000,
                    			(int)system_time, (int)(system_time * 1000) % 1000,
                    			(int)real_time, (int)(real_time * 1000) % 1000);
							}

        	     		 } else {

            					perror("Error al crear el proceso hijo");
								exit(1);
        	     		 }
						
    		 		}
			 } /*if (strcmp(argv[0], "read") == 0) {
				  char *input=(char *)malloc(128 * sizeof(char));
				  char ***env_vars=(char ***)malloc(128 * sizeof(char));;

				  if (fgets(input,128 * sizeof(char),stdin)==NULL){
					 printf("Error al leer de la entrada");
					 exit(1);
				  }
				  size_t len = strlen(input);
    			  if (len > 0 && input[len - 1] == '\n') {
        				input[len - 1] = '\0';
				  }
				  printf("%s %s",argvv[0][1],argvv[0][2]);
				  int i=0;
				  while (argvv[0][i+1]!=NULL){
					printf("aqui1");
					env_vars[0][i]=argvv[0][i];
					i++;
					printf("%s",env_vars[0][i]);
				  }
				  while(env_vars[0][i]!=NULL){
					printf("aqui2");
					printf("%s",env_vars[0][i]);
				  }*/

				  
				  /*
				  int i = 0;
    			  char *word = strtok(input, " \t");
   				  while (word != NULL && env_vars[i] != NULL) {
        				char *env_string = malloc(strlen(env_vars[i]) + strlen(word) + 2);  // +2 para el '=' y '\0'
       					sprintf(env_string, "%s=%s", env_vars[i], word);
        				if (putenv(env_string) != 0) {
            					printf("Error al establecer la variable de entorno %s\n", env_vars[i]);
            					free(env_string);
           		 				exit(1);
        				}
        				i++;
        				word = strtok(NULL, " \t");
    				}
				  if (word != NULL && env_vars[i] != NULL) {
        				char *rest_of_line = word;
        				char *env_string = malloc(strlen(env_vars[i]) + strlen(rest_of_line) + 2);  // +2 para el '=' y '\0'
        				sprintf(env_string, "%s=%s", env_vars[i], rest_of_line);
       					 if (putenv(env_string) != 0) {
            					printf("Error al establecer la variable de entorno %s\n", env_vars[i]);
            					free(env_string);
            					exit(1);
        				  }
    				}
					*/
			 //}
			 
			 if((strcmp(argv[0], "cd") != 0) && (strcmp(argv[0], "umask") != 0) && (strcmp(argv[0], "time") != 0) && (strcmp(argv[0], "read") != 0)){

				pid_t pid=fork();
				if (pid<0){
					perror("fork");
					exit (1);
				}
				else if (pid == 0){
					if(strcmp(argvv[0][0],"echo")==0){
						if(argvv[0][1]!=NULL){	
							int i=0;
							char *output=(char *)malloc(128 * sizeof(char));
							output=argvv[0][1];
							//printf("%s\n",output);
							char *username=(char *)malloc(128 * sizeof(char));
							char *varname=(char *)malloc(128 * sizeof(char));
							char *aux=(char *)malloc(128 * sizeof(char));
							int j=0;
							if (output[0]=='~' || output[0]=='$' || output[0]=='/'){
							   //printf("aqui1\n");
							   if (filev[1]){
									int fdout=creat(filev[1],0666);
									if(fdout==-1){
										perror("error al abrir el archivo de salida");
										exit(1);
									}
									while(output[i] != '\0'){
											
											if(output[0]=='~'){
												dprintf(fdout,"%s\n",getenv("HOME"));
												break;
											}
											if (output[0]=='$'){
												//i++;
												//int j = 0;
												while (output[i] != '\0' && sscanf(&output[i], "%[_a-zA-Z0-9]", &username[j])) {
													if(strcmp(username,"HOME")==0){
														//username=getenv(username);
														char *dir= getenv(username);
														dprintf(fdout,"%s\n",dir);break;
													}
													j++;
													i++;
												}
												//printf("%s\n",output);
												//break;
											}
											if(output[0]=='/'){
												while (output[i] != '\0' ){
													aux[i]=output[i];
													if(output[i]=='$'){
														int z=0;
														aux[i]='\0';
														int cont=i;
														i++;
												
														while (output[i]!='\0' && sscanf(&output[i], "%[_a-zA-Z0-9]", &varname[z])) {
											
															//printf("%s",output);break;
															if(strcmp(varname,"HOME")==0){
														
																char *ent= getenv(varname);
																//printf("%s\n",ent);
																for(int x=0 ; x<strlen(ent) ; x++){
																	aux[cont + x]=ent[x];
																}
																int res=strlen(aux);
																int cont2=i+strlen(varname);
																while(output[cont2]!='\0'){
																	aux[res]=output[cont2];
																	res++;
																	cont2++;
																}
																dprintf(fdout,"%s\n",aux);break;
																
															}

															z++;
															i++;
														}

													}
													j++;
													i++;
												}
												int encontrado=0;
												for(int i=0;i<strlen(output);i++){
													if(output[i]=='$'){
														encontrado=1;break;
													}
												}
												if(encontrado==0){
													dprintf(fdout,"%s\n",output);
													break;
												}
												
											}
											i++;
									}

									close(fdout);
									break;
							   }
							   while(output[i] != '\0'){
									
									if(output[0]=='~'){
										printf("%s\n",getenv("HOME"));
										break;
									}
									if (output[0]=='$'){
										//i++;
										//int j = 0;
										while (output[i] != '\0' && sscanf(&output[i], "%[_a-zA-Z0-9]", &username[j])) {
											if(strcmp(username,"HOME")==0){
												//username=getenv(username);
												char *dir= getenv(username);
												printf("%s\n",dir);break;
											}
											j++;
											i++;
										}
										//printf("%s\n",output);
										//break;
									}
									if(output[0]=='/'){
										while (output[i] != '\0' ){
											aux[i]=output[i];
											if(output[i]=='$'){
												int z=0;
												aux[i]='\0';
												int cont=i;
												i++;
										
												while (output[i]!='\0' && sscanf(&output[i], "%[_a-zA-Z0-9]", &varname[z])) {
									
													//printf("%s",output);break;
													if(strcmp(varname,"HOME")==0){
												
														char *ent= getenv(varname);
														//printf("%s\n",ent);
														for(int x=0 ; x<strlen(ent) ; x++){
															aux[cont + x]=ent[x];
														}
														int res=strlen(aux);
														int cont2=i+strlen(varname);
														while(output[cont2]!='\0'){
															aux[res]=output[cont2];
															res++;
															cont2++;
														}
														printf("%s\n",aux);break;
														
													}

													z++;
													i++;
												}

											}
											j++;
											i++;
										}
										int encontrado=0;
										for(int i=0;i<strlen(output);i++){
											if(output[i]=='$'){
												encontrado=1;break;
											}
										}
										if(encontrado==0){
											printf("%s\n",output);
											break;
										}
										
									}
									i++;
							   }

							   
							   break;
							}

						}

					}

					if (filev[0]) {
						int fdin=open(filev[0],O_RDONLY);
						if(fdin==-1){
							perror("error al abrir el archivo de entrada");
							exit(1);
						}
						dup2(fdin,0);
						close(fdin);
					}
					if (filev[1]) {
						int fdout=creat(filev[1],0666);
						if(fdout==-1){
							perror("error al abrir el archivo de salida");
							exit(1);
						}
						dup2(fdout,1);
						close(fdout);
					}
					if (filev[2]){
						int fderr=creat(filev[2],0666);
						if(fderr==-1){
							perror("error al abrir el archivo de error");
							exit(1);
						}
						dup2(fderr,2);
						close(fderr);
					}
					if(!bg){
						act.sa_handler=SIG_DFL;
                		act.sa_flags=0;
        				sigaction(SIGINT,&act,NULL);
        				act2.sa_handler=SIG_DFL;
        				act2.sa_flags=0;
        				sigaction(SIGQUIT,&act2,NULL);
			 		}
					if (bg) printf("&\n");
					if(argvc>0){

                        dup2(salida,0);
                        close(salida);//si pongo salida igual 
                        //close(tub[1]);
                    }

					if (argvv[argvc+1]!=NULL){
						//close(tub[0]);
						dup2(tub[1],1);
						close(tub[1]);
					}

					execvp(argv[0],argv);
					perror("exec");
					exit (1);

				}else{
					if(argvc>0){
                                                close(salida);
					}
					if (argvv[argvc+1]!=NULL){
						salida=tub[0];
						close(tub[1]);
                                               // salida=tub[0];

					}
					if(!bg){
						int status;
						if (argvv[argvc+1]==NULL){
						   waitpid(pid,&status,0);
						}
					}
				}

			  } 

		}

/*
 * FIN DE LA PARTE A ELIMINAR
 */
#endif
	}
	exit(0);
	return 0;
}
