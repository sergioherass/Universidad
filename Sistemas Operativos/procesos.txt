Suponga que el fragmento de código que aparece a continuación corresponde al esquema de
operación de un servidor concurrente que debe estar en funcionamiento continuamente en un
sistema de una determinada organización.
int main(...){
struct peticion pet;
pid_t pid;
while(1){
esperar_peticion(&pet);
pid = fork();
switch(pid){
case -1:
perror("fork"); exit(1);
case 0:
procesar_peticion(&pet); // operación muy larga
exit(0);
}
}
return 0;
}
a) ¿Qué problema de agotamiento de recursos puede presentarse al usar este esquema?
El problema de agotamiento de recursos que puede presentarse al usar este esquema es la acumulación de procesos hijos en estado "zombie".

Cuando un proceso hijo termina su ejecución, no desaparece completamente del sistema hasta que el proceso padre lo haya reconocido. Esto se hace a través de una llamada al sistema wait() o waitpid(), que permite al proceso padre recoger el estado de salida del hijo y así eliminarlo del sistema.

En el código proporcionado, no hay una llamada a wait() o waitpid() en el proceso padre, por lo que cada vez que un proceso hijo termina, se convierte en un proceso "zombie". Estos procesos ocupan recursos del sistema (principalmente entradas en la tabla de procesos) y, si se acumulan en gran número, pueden agotar estos recursos, lo que afectaría el rendimiento y la estabilidad del servidor concurrente y del sistema en general.

Para evitar este problema, se puede agregar una llamada a waitpid() con la opción WNOHANG en un bucle para limpiar a los procesos hijos terminados, o se puede utilizar la señal SIGCHLD junto con un manejador de señales para llamar a wait() o waitpid() cuando un proceso hijo termina.




cocajuniors1234@gmail.com
vale , puedes explicarme detalladamente el codigo por favor
Claro, a continuación se presenta una descripción detallada del código:

c
Copy code
int main(...) {
    struct peticion pet; // Define una estructura "peticion" llamada "pet"
    pid_t pid; // Define una variable "pid" de tipo "pid_t" para almacenar el ID del proceso

    while (1) { // Bucle infinito para mantener el servidor en funcionamiento continuamente
        esperar_peticion(&pet); // Espera y recibe una petición y almacena la información en la estructura "pet"

        pid = fork(); // Crea un nuevo proceso duplicando el proceso actual, el ID del proceso hijo se almacena en "pid" en el proceso padre y 0 en el proceso hijo

        switch (pid) { // Evalúa el valor de "pid"
            case -1: // Si "pid" es -1, entonces ocurrió un error al crear el proceso hijo
                perror("fork"); // Muestra un mensaje de error relacionado con "fork()"
                exit(1); // Termina el proceso con un código de error 1

            case 0: // Si "pid" es 0, entonces estamos en el proceso hijo
                procesar_peticion(&pet); // Procesa la petición recibida (operación muy larga)
                exit(0); // Termina el proceso hijo con un código de éxito 0
        }
        // Si "pid" es mayor a 0, entonces estamos en el proceso padre y el "switch" no hace nada, el proceso padre vuelve al inicio del bucle "while" y espera la siguiente petición
    }

    return 0; // En teoría, el programa nunca debería llegar a este punto, pero se incluye por completitud
}
Este código representa un servidor concurrente que utiliza procesos para manejar las peticiones de los clientes. El servidor opera en un bucle infinito, esperando y procesando peticiones de manera continua.

Cuando se recibe una petición, el servidor crea un nuevo proceso utilizando la función fork(). El proceso hijo resultante es una copia exacta del proceso padre, y la función fork() devuelve 0 en el proceso hijo y el ID del proceso hijo en el proceso padre.

Dentro del proceso hijo, se procesa la petición utilizando la función procesar_peticion(), que se supone que es una operación larga. Una vez que el proceso hijo ha terminado de procesar la petición, termina su ejecución utilizando la función exit(0).

Mientras tanto, el proceso padre continúa en el bucle infinito, esperando y procesando nuevas peticiones. Sin embargo, como mencioné anteriormente, el código no incluye una llamada a wait() o waitpid() para lidiar con la finalización de los procesos hijos, lo que puede llevar al agotamiento de recursos del sistema debido a la acumulación de procesos zombies.




cocajuniors1234@gmail.com
que hace el wait
La función wait() es una llamada al sistema en los sistemas operativos basados en Unix y POSIX que permite a un proceso padre esperar la finalización de uno de sus procesos hijos. Cuando un proceso hijo termina su ejecución, no desaparece completamente del sistema hasta que el proceso padre lo haya reconocido, es decir, haya "esperado" por él.

La función wait() realiza las siguientes acciones:

Bloquea al proceso padre mientras espera a que cualquiera de sus procesos hijos termine. Si ya hay un proceso hijo terminado, wait() retorna inmediatamente.
Recoge el estado de salida del proceso hijo terminado.
Libera los recursos del sistema asociados con el proceso hijo, permitiendo que el proceso hijo sea eliminado del sistema.
Cuando se utiliza wait(), el proceso hijo que ha terminado su ejecución se convierte en un proceso "zombie" temporalmente hasta que el proceso padre lo reconozca. Una vez que el proceso padre ha esperado al proceso hijo utilizando wait(), el proceso hijo es eliminado del sistema y deja de ser un proceso zombie.

La función wait() se declara en la biblioteca de C <sys/wait.h> y tiene la siguiente firma:

c
Copy code
pid_t wait(int *status);
Donde status es un puntero a un entero que almacenará el estado de salida del proceso hijo que ha terminado.

El valor de retorno de wait() es el ID del proceso hijo que ha terminado. Si no hay ningún proceso hijo, wait() retorna -1 y establece la variable errno con el código de error correspondiente.

En general, se recomienda utilizar wait() o sus variantes, como waitpid(), en un servidor concurrente




cocajuniors1234@gmail.com
como se mata un proceso
Para matar (terminar) un proceso en sistemas operativos basados en Unix y POSIX, puedes utilizar la función kill(), que envía una señal a




cocajuniors1234@gmail.com
Para paliar este problema sin afectar al paralelismo de la solución, uno de los programadores más
expertos de la organización propone este esquema alternativo.
int main(...){
struct peticion pet;
pid_t pid1, pid2;
while(1){
esperar_peticion(&pet);
pid1 = fork();
switch(pid1){
case -1:
perror("fork"); exit(1);
case 0:
if ((pid2 = fork()) == -1) {
perror("fork");
exit(1);
}
else if (pid2 > 0)
exit(0);
else {
procesar_peticion(&pet); // operación muy larga
exit(0);
}
default:
wait(NULL);
}
}
return 0;
}
b) Explique cómo resuelve este nuevo esquema el problema identificado.
Este nuevo esquema resuelve el problema de agotamiento de recursos debido a la acumulación de procesos zombie utilizando un enfoque de doble fork(). Aquí hay una explicación detallada de cómo funciona:

Al igual que en el esquema original, el servidor espera una petición y crea un proceso hijo utilizando fork(). El proceso hijo creado es el "primer proceso hijo" (con ID pid1).

En el primer proceso hijo, se crea otro proceso hijo utilizando otro fork(). Este nuevo proceso hijo es el "segundo proceso hijo" (con ID pid2).

En el segundo proceso hijo, se procesa la petición (operación muy larga) y luego se termina el proceso llamando a exit(0).

En el primer proceso hijo, después de crear el segundo proceso hijo, se verifica si la creación fue exitosa y, si es así, se termina inmediatamente el primer proceso hijo llamando a exit(0).

En el proceso padre, después de crear el primer proceso hijo, se llama a wait(NULL) para esperar a que el primer proceso hijo termine. Dado que el primer proceso hijo termina casi de inmediato después de crear el segundo proceso hijo, no se bloquea el paralelismo.

Entonces, ¿cómo resuelve este esquema el problema de los procesos zombie? Cuando el primer proceso hijo termina, el proceso padre lo espera utilizando wait(NULL) y limpia sus recursos, evitando que se convierta en un proceso zombie. Por otro lado, cuando el segundo proceso hijo termina, se convierte en un proceso "zombie" temporalmente, pero como su proceso padre (el primer proceso hijo) ya ha terminado, este proceso zombie es "adoptado" automáticamente por el proceso "init" (o "systemd" en algunos sistemas), que es el proceso con ID 1 en el sistema.

El proceso "init" (o "systemd") periódicamente espera a sus procesos hijos y limpia sus recursos, por lo que el segundo proceso hijo zombie no se acumulará en el sistema y no agotará los recursos. De esta manera, este esquema alternativo resuelve el problema de agotamiento de recursos debido a la acumulación de procesos zombies sin afectar el paralelismo de la solución.




cocajuniors1234@gmail.com
Dado el siguiente programa:  int main(void){
int s, n, k = 0;
pid_t p1;
for(n = 0; n < 3; ){
p1 = fork();
switch(p1){
case -1:
perror("fork"); exit(1);
case 0:
if(getpid()%2 == 0)
exit(0);
else
exit(1);
default:
k++;
wait(&s);
if(WIFEXITED(s))
if(WEXITSTATUS(s) == 0)
n++;
}
}
printf("k = %i\n", k);
return 0;
} , a) ¿Qué contiene la variable p1?
b) ¿Qué sentencias del cuerpo del switch corresponden al proceso hijo?
c) ¿Qué función realiza el proceso hijo? (Recuerde que “a % b” es el resto de la división entera de a
entre b)
d) ¿Qué función realiza la macro WEXITSTATUS()?
e) ¿Qué operaciones hace el proceso padre tras crear al proceso hijo?
f) ¿Cuántos procesos hijo pueden existir al mismo tiempo? ¿Por qué?
g)¿Qué información contienen las variables k y n al final de cada iteración del bucle for?
h) ¿Puede en algún caso caso iterar indefinidamente el bucle for? Si es así, ¿en cuál?
i) ¿Qué información contiene la variable k al final del programa?
j) ¿Qué escribe el programa en la salida estándar si el sistema operativo asigna la siguiente
secuencia de PIDs a los procesos hijo: 29180, 29181, 29182, 29183, 29184, 29185, 29186, 29187,
etc.?
a) La variable p1 contiene el ID del proceso hijo creado por la llamada a fork() en el proceso padre. Si fork() es exitoso, p1 contendrá el ID del proceso hijo en el proceso padre y 0 en el proceso hijo. Si fork() falla, p1 contendrá -1.

b) Las sentencias del cuerpo del switch que corresponden al proceso hijo son las que se encuentran en el bloque case 0:.

c) El proceso hijo verifica si su ID de proceso (PID) es par o impar utilizando la expresión getpid() % 2. Si el PID es par, el proceso hijo termina con el estado de salida 0, de lo contrario, termina con el estado de salida 1.

d) La macro WEXITSTATUS() toma el estado de salida proporcionado por el proceso hijo y extrae el estado de salida real que el proceso hijo pasó a la función exit(). Es decir, si el proceso hijo llamó a exit(0), WEXITSTATUS(s) devolverá 0, y si llamó a exit(1), devolverá 1.

e) Después de crear al proceso hijo, el proceso padre realiza las siguientes operaciones:

Incrementa la variable k en 1.
Llama a wait(&s) para esperar a que el proceso hijo termine y almacenar el estado de salida en la variable s.
Utiliza la macro WIFEXITED(s) para verificar si el proceso hijo terminó normalmente.
Utiliza la macro WEXITSTATUS(s) para verificar el estado de salida del proceso hijo. Si es 0, incrementa la variable n en 1.
f) Solo puede haber un proceso hijo existente al mismo tiempo. Esto se debe a que el proceso padre espera a que el proceso hijo termine en cada iteración del bucle for utilizando wait(&s) antes de continuar con la siguiente iteración y crear otro proceso hijo.

g) Al final de cada iteración del bucle for, la variable k contiene la cantidad de procesos hijos que se han creado hasta el momento, y la variable n contiene la cantidad de procesos hijos que han terminado con un estado de salida 0.

h) No, el bucle for no puede iterar indefinidamente. En cada iteración, se crea un proceso hijo y se espera a que termine. Si el proceso hijo termina con un estado de salida 0, la variable n se incrementa en 1. El bucle terminará cuando n alcance 3.

i) Al final del programa, la variable k contiene la cantidad total de procesos hijos que se han creado.

j) Si la secuencia de PIDs asignados a los procesos hijos es 29180, 29181, 29182, 29183, 29184, 29185, 29186, 29187, etc., entonces el programa escribirá "k = 6" en la salida estándar. Esto se debe a que el bucle for terminará después de que se hayan creado 3 procesos hijos con PIDs pares (29180, 29182 y 29184), y para alcanzar ese punto, se habrán creado en total 6 procesos hijos (tres con PIDs pares y tres con PIDs impares).




cocajuniors1234@gmail.com
Escribir un programa que cree N generaciones padre-hijo. Cada pareja padre-hijo se deben
comunicar con un pipe unidireccional padre->hijo
A continuación, se presenta un programa en C que crea N generaciones de relaciones padre-hijo. Cada pareja padre-hijo se comunica mediante un pipe unidireccional desde el padre al hijo:

c
Copy code
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Uso: %s N\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int N = atoi(argv[1]);
    int pipefd[2];
    pid_t pid;

    for (int i = 0; i < N; i++) {
        if (pipe(pipefd) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }

        pid = fork();

        if (pid == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }

        if (pid == 0) {
            // Proceso hijo
            close(pipefd[1]); // Cierra el extremo de escritura del pipe
            int mensaje;
            read(pipefd[0], &mensaje, sizeof(int));
            printf("Hijo %d (PID: %d) recibió mensaje '%d' del padre (PID: %d)\n", i + 1, getpid(), mensaje, getppid());
            close(pipefd[0]); // Cierra el extremo de lectura del pipe
        } else {
            // Proceso padre
            close(pipefd[0]); // Cierra el extremo de lectura del pipe
            int mensaje = i + 1;
            write(pipefd[1], &mensaje, sizeof(int));
            close(pipefd[1]); // Cierra el extremo de escritura del pipe
            wait(NULL); // Espera a que el proceso hijo termine
            exit(EXIT_SUCCESS);
        }
    }

    return 0;
}
Este programa crea N generaciones de relaciones padre-hijo utilizando un bucle for. En cada iteración del bucle, se crea un pipe y se utiliza la función fork() para crear un proceso hijo. El proceso padre escribe un mensaje (un número entero en este caso) en el pipe, mientras que el proceso hijo lee el mensaje del pipe y lo imprime en la salida estándar. Después de que el proceso hijo haya leído el mensaje, el proceso padre espera a que el proceso hijo termine antes de salir.

Para compilar y ejecutar este programa, guarda el código en un archivo llamado generaciones.c y, a continuación, ejecuta los siguientes comandos en una terminal:

bash
Copy code
gcc -o generaciones generaciones.c
./generaciones N
Reemplaza N con el número de generaciones padre-hijo que deseas crear.




cocajuniors1234@gmail.com
Escribir un programa que cree N procesos hijo, tomando N del primer argumento de la línea de
mandato. Cada pareja de hijos consecutivos i e i+1 se deben comunicar entre sí con un pipe
unidireccional hijo i --> hijo i+1. El último hijo debe comunicarse mediante pipe unidireccional con
el primer hijo (último hijo → primer hijo)
Aquí tienes un programa en C que crea N procesos hijos, donde N se toma del primer argumento de la línea de comando. Cada pareja de hijos consecutivos i e i + 1 se comunica entre sí mediante un pipe unidireccional hijo i → hijo i + 1. El último hijo se comunica mediante pipe unidireccional con el primer hijo (último hijo → primer hijo):

c
Copy code
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Uso: %s N\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int N = atoi(argv[1]);
    int pipefds[N][2];
    pid_t pids[N];

    // Crear todos los pipes
    for (int i = 0; i < N; i++) {
        if (pipe(pipefds[i]) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }
    }

    for (int i = 0; i < N; i++) {
        pids[i] = fork();

        if (pids[i] == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }

        if (pids[i] == 0) {
            // Proceso hijo
            for (int j = 0; j < N; j++) {
                if (j != i) {
                    close(pipefds[j][1]);
                }
                if (j != (i + 1) % N) {
                    close(pipefds[j][0]);
                }
            }

            int mensaje;
            read(pipefds[(i + 1) % N][0], &mensaje, sizeof(int));
            printf("Hijo %d (PID: %d) recibió mensaje '%d' del hijo %d (PID: %d)\n", i + 1, getpid(), mensaje, i == 0 ? N : i, i == 0 ? pids[N - 1] : pids[i - 1]);
            mensaje++;
            write(pipefds[i][1], &mensaje, sizeof(int));

            for (int j = 0; j < N; j++) {
                if (j != i) {
                    close(pipefds[j][1]);
                }
                if (j != (i + 1) % N) {
                    close(pipefds[j][0]);
                }
            }

            exit(EXIT_SUCCESS);
        }
    }

    // Proceso padre
    for (int i = 0; i < N; i++) {
        if (i != 0) {
            close(pipefds[i][1]);
        }
        if (i != N - 1) {
            close(pipefds[i][0]);
        }
    }

    int mensaje = 1;
    write(pipefds[0][1], &mensaje, sizeof(int));
    read(pipefds[N - 1][0], &mensaje, sizeof(int));
    printf("Padre (PID: %d) recibió mensaje '%d' del último hijo (PID: %d)\n", getpid(), mensaje, pids[N - 1]);

    for (int i = 0; i < N; i++) {
        wait(NULL);
    }

    return 0;
}
Este programa crea N procesos hijos y N pipes utilizando dos bucles for. Luego, en cada proceso hijo, se cierran los extremos innecesarios del pipe y se realiza la lectura y escritura en




cocajuniors1234@gmail.com
Escribir un programa que cree cuatro procesos, que denominaremos de forma lógica P0, P1, P2 y
P3. Estos cuatro procesos estarán comunicados entre ellos a través de un único pipe, de solo lectura
para P0 y solo escritura para P1, P2 y P3. Los procesos P1, P2 y P3 escribirán en el pipe 1 carácter
que los identifica ('1' = P1, '2' = P2 y '3' = P3) y terminarán y el proceso P0 leerá los caracteres y los
imprimirá por stdout.
Aquí tienes un programa en C que crea cuatro procesos denominados de forma lógica P0, P1, P2 y P3. Los procesos P1, P2 y P3 escriben un carácter que los identifica en un único pipe, mientras que P0 lee estos caracteres e imprime en stdout:

c
Copy code
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    pid_t pids[4];

    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 4; i++) {
        pids[i] = fork();

        if (pids[i] == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }

        if (pids[i] == 0) {
            if (i == 0) { // Proceso P0
                close(pipefd[1]); // Cierra el extremo de escritura del pipe

                char caracter;
                for (int j = 1; j <= 3; j++) {
                    read(pipefd[0], &caracter, sizeof(char));
                    printf("P0 (PID: %d) recibió '%c' del proceso P%d (PID: %d)\n", getpid(), caracter, j, pids[j]);
                }
                close(pipefd[0]); // Cierra el extremo de lectura del pipe
            } else { // Procesos P1, P2 y P3
                close(pipefd[0]); // Cierra el extremo de lectura del pipe

                char caracter = '0' + i;
                write(pipefd[1], &caracter, sizeof(char));

                close(pipefd[1]); // Cierra el extremo de escritura del pipe
                exit(EXIT_SUCCESS);
            }
        }
    }

    // Proceso padre
    close(pipefd[0]);
    close(pipefd[1]);

    for (int i = 0; i < 4; i++) {
        wait(NULL);
    }

    return 0;
}
Este programa crea un pipe y cuatro procesos utilizando un bucle for. Los procesos P1, P2 y P3 escriben su identificador en el pipe y luego terminan. El proceso P0 lee los caracteres del pipe y los imprime en stdout. El proceso padre espera a que todos los procesos hijos terminen antes de finalizar.

Para compilar y ejecutar este programa, guarda el código en un archivo llamado procesos_comunicados.c y, a continuación, ejecuta los siguientes comandos en una terminal:

bash
Copy code
gcc -o procesos_comunicados procesos_comunicados.c
./procesos_comunicados


