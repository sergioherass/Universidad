# Define SciTE settings for Haskell files.
# Pepe Gallardo, 2009


file.patterns.haskell=*.hs;*.lhs


filter.haskell=Haskell (hs lhs)|$(file.patterns.haskell)|

file.patterns.braces=$(file.patterns.haskell)

lexer.$(file.patterns.haskell)=haskell

api.$(file.patterns.haskell)=$(SciteDefaultHome)/Haskell.Prelude.api

autocomplete.haskell.start.characters=$(chars.alpha)+-*<>=/&|$%:^.
#autocompleteword.automatic=1

calltip.haskell.word.characters=$(chars.alpha)$(chars.numeric)_'+-*<>=/&|$%:^.
#calltip.haskell.end.definition=

# shows calltips on mouse over
dwell.period=750


# keywords1 is for reserved words
keywords.$(file.patterns.haskell)=case class \
data default deriving do \
else \
hidding \
if import in infix infixl infixr instance \
let \
module \
newtype \
of \
primitive \
qualified \
then type \
where


# keywords2 is for predefined types
keywords2.$(file.patterns.haskell)=Bool \
Char \
Double \
Either \
FilePath Float \
Int Integer IO IOError IOResult \
Maybe \
Ordering \
Ratio Rational ReadS \
ShowS String


# keywords3 is for predefined classes
keywords3.$(file.patterns.haskell)=Bounded Enum Eq \
Floating Fractional Functor \
Integral Ix \
Monad \
Num \
Ord \
Read Real RealFloat RealFrac \
Show


# keywords4 is for predefined values
keywords4.$(file.patterns.haskell)=EQ \
False \
GT \
Just \
Left LT \
Nothing \
Right \
True



word.characters.$(file.patterns.haskell)=$(chars.alpha)$(chars.numeric)_'

comment.block.haskell=-- 
#comment.block.at.line.start.haskell=1
comment.stream.start.haskell={-
comment.stream.end.haskell=-}
comment.box.start.haskell={-
comment.box.middle.haskell= *
comment.box.end.haskell= -}
fold.comment=0
fold.preprocessor=0
#fold.at.else=1


#statement.indent.$(file.patterns.haskell)=5 case else if in let of then where
# statement.end.$(file.patterns.haskell)=10 ;
statement.lookback.$(file.patterns.haskell)=20
#block.start.$(file.patterns.haskell)=10 {
#block.end.$(file.patterns.haskell)=10 }


#autocomplete.haskell.fillups=(

#styling.within.preprocessor=1
preprocessor.symbol.$(file.patterns.haskell)=#
preprocessor.start.$(file.patterns.haskell)=if ifdef ifndef
preprocessor.middle.$(file.patterns.haskell)=else elif
preprocessor.end.$(file.patterns.haskell)=endif



# Haskell styles

colour.const=fore:#CC0000
colour.number=$(colour.const)
colour.string=$(colour.const)
colour.char=$(colour.const)

colour.comment=fore:#646464
colour.code.comment.box=$(colour.comment)
colour.code.comment.line=$(colour.comment)
colour.code.comment.doc=$(colour.comment)



#font.comment=font:Lucida console,size:9
font.code.comment.box=$(font.comment)
font.code.comment.line=$(font.comment)
font.code.comment.doc=$(font.comment)




# Default
style.haskell.32=$(font.base)

# Spaces
style.haskell.0=$(font.base)
# Braces are only matched in default style


# Comment
style.haskell.1=$(colour.code.comment.box),$(font.code.comment.box)
# Line Comment
style.haskell.2=$(colour.code.comment.line),$(font.code.comment.line)
# Doc comment
style.haskell.3=$(colour.code.comment.doc),$(font.code.comment.doc)


# Number
style.haskell.3=$(colour.number)

# Keyword
style.haskell.4=$(colour.keyword),bold
# Keywords2
style.haskell.5=fore:#009100
# Keywords3
style.haskell.6=fore:#000099
# Keywords4
style.haskell.7=$(colour.const)
# Keywords5
style.haskell.8=fore:#B00040,bold


# Double quoted string
style.haskell.9=$(colour.string)
# Single quoted string
style.haskell.10=$(colour.char)

# Operators
style.haskell.11=fore:#AA00BB

# Identifiers
style.haskell.12=

# End of line where string is not closed
style.haskell.13=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled

# separators
style.haskell.14=fore:#FF0000
braces.haskell.style=14

#nonmatching braces
style.haskell.35=bold

calltip.haskell.end.definition=;




GhciExe=ghci.exe
GhcExe=ghc.exe
WinhugsExe="$(SciteDefaultHome)\..\..\winhugs.exe"
HugsExe="$(SciteDefaultHome)\..\..\hugs.exe"
RunhugsExe="$(SciteDefaultHome)\..\..\runhugs.exe"

InvokeGhci=$(GhciExe) "$(FileNameExt)"
InvokeGhc=$(GhcExe) -c "$(FileNameExt)"
InvokeWinhugs=$(WinhugsExe) "$(FileNameExt)"
InvokeHugs=$(HugsExe) +. "$(FileNameExt)"
InvokeRunhugs=$(RunhugsExe) "$(FileNameExt)"

command.compile.save.before.$(file.patterns.haskell)=1
command.compile.subsystem.$(file.patterns.haskell)=1
command.compile.$(file.patterns.haskell)=$(InvokeGhc)

command.go.save.before.$(file.patterns.haskell)=1
command.go.$(file.patterns.haskell)=$(InvokeGhci)

command.save.before.0.$(file.patterns.haskell)=1
command.name.0.$(file.patterns.haskell)=Hugs
command.0.$(file.patterns.haskell)=$(InvokeHugs)

command.save.before.1.$(file.patterns.haskell)=1
command.subsystem.1.$(file.patterns.haskell)=1
command.name.1.$(file.patterns.haskell)=WinHugs
command.1.$(file.patterns.haskell)=$(InvokeWinhugs)


