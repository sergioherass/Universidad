!!(:: [a] -> Int -> a)
$!(:: (a -> b) -> a -> b)
$(:: (a -> b) -> a -> b)
%(:: Integral a => a -> a -> Ratio a)
&&(:: Bool -> Bool -> Bool)
*(:: Num a => a -> a -> a)
**(:: Floating a => a -> a -> a)
+(:: Num a => a -> a -> a)
++(:: [a] -> [a] -> [a])
-(:: Num a => a -> a -> a)
->( arrow type or lambda expression)
.(:: (a -> b) -> (c -> a) -> c -> b)
..( arithmetic sequence)
/(:: Fractional a => a -> a -> a)
/=(:: Eq a => a -> a -> Bool)
:%(:: Integral a => a -> a -> Ratio a)
:(:: a -> [a] -> [a])
<(:: Ord a => a -> a -> Bool)
<-( list comprehension or monadic binding)
<=(:: Ord a => a -> a -> Bool)
=( defines)
=<<(:: Monad a => (b -> a c) -> a b -> a c)
==(:: Eq a => a -> a -> Bool)
=>( class context) 
>(:: Ord a => a -> a -> Bool)
>=(:: Ord a => a -> a -> Bool)
>>(:: Monad a => a b -> a c -> a c)
>>=(:: Monad a => a b -> (b -> a c) -> a c)
@(as pattern)
Bool( Boolean type)
Bounded( Bound class)
Char( Character type) 
Double( Double precision Real number type) 
EQ(:: Ordering)
Either( Sum type)
EmptyRec(:: Rec EmptyRow)
Enum( Enumeration class)
Eq( Equality class)
False(:: Bool)
FilePath( File path type)
Float( Single precision Real number type)
Floating( Floating number class)
Fractional( Fractional number class)
Functor( Functor class)
GT(:: Ordering)
IO( Input/Output type)
IOError( Input/Output error type)
Int( Integer number type)
Integer( Unlimited precision Integer number type)
Integral( Integral class)
Ix( Index class)
Just(:: a -> Maybe a)
LT(:: Ordering)
Left(:: a -> Either a b)
Maybe( Maybe type)
Monad( Monad class)
Nothing(:: Maybe a)
Num( Number class)
Obj(:: Obj)
Ord( Order class)
Ordering( Ordering type)
Ratio( Rational polymorphic number type)
Rational( Rational type)
Read( Read class)
ReadS( ReadS Type)
Real( Real class )
RealFloat( RealFloat class)
RealFrac( RealFrac class)
Right(:: b -> Either a b)
Show( Show class)
ShowS(ShowS type)
String( String of characters type)
True(:: Bool)
[](:: [a])
\( lambda expression)
^(:: (Num a, Integral b) => a -> b -> a)
^^(:: (Fractional a, Integral b) => a -> b -> a)
abs(:: Num a => a -> a)
absReal(:: (Num a, Ord a) => a -> a)
acos(:: Floating a => a -> a)
acosh(:: Floating a => a -> a)
all(:: (a -> Bool) -> [a] -> Bool)
and(:: [Bool] -> Bool)
any(:: (a -> Bool) -> [a] -> Bool)
appendFile(:: FilePath -> String -> IO ())
asTypeOf(:: a -> a -> a)
asciiTab(:: [(Char,[Char])])
asin(:: Floating a => a -> a)
asinh(:: Floating a => a -> a)
atan(:: Floating a => a -> a)
atan2(:: RealFloat a => a -> a -> a)
atanh(:: Floating a => a -> a)
basicIORun(:: IO a -> IOFinished a)
blockIO(:: ((a -> IOResult) -> IO ()) -> IO a)
break(:: (a -> Bool) -> [a] -> ([a],[a]))
case( case of selection)
catch(:: IO a -> (IOError -> IO a) -> IO a)
catchHugsException(:: IO a -> (HugsException -> IO a) -> IO a)
ceiling(:: (RealFrac a, Integral b) => a -> b)
class(class definition)
compare(:: Ord a => a -> a -> Ordering)
concat(:: [[a]] -> [a])
concatMap(:: (a -> [b]) -> [a] -> [b])
const(:: a -> b -> a)
cos(:: Floating a => a -> a)
cosh(:: Floating a => a -> a)
curry(:: ((a,b) -> c) -> a -> b -> c)
cycle(:: [a] -> [a])
data( data type definition)
decodeFloat(:: RealFloat a => a -> (Integer,Int))
default
denominator(:: Integral a => Ratio a -> a)
deriving( automatic instance derivation)
div(:: Integral a => a -> a -> a)
divMod(:: Integral a => a -> a -> (a,a))
do(  monadic do expression)
doubleToFloat(:: Double -> Float)
doubleToRatio(:: Integral a => Double -> Ratio a)
doubleToRational(:: Double -> Rational)
drop(:: Int -> [a] -> [a])
dropWhile(:: (a -> Bool) -> [a] -> [a])
either(:: (a -> b) -> (c -> b) -> Either a c -> b)
elem(:: Eq a => a -> [a] -> Bool)
else( conditional expresion )
encodeFloat(:: RealFloat a => Integer -> Int -> a)
enumFrom(:: Enum a => a -> [a])
enumFromThen(:: Enum a => a -> a -> [a])
enumFromThenTo(:: Enum a => a -> a -> a -> [a])
enumFromTo(:: Enum a => a -> a -> [a])
error(:: String -> a)
even(:: Integral a => a -> Bool)
exp(:: Floating a => a -> a)
exponent(:: RealFloat a => a -> Int)
fail(:: Monad a => String -> a b)
filter(:: (a -> Bool) -> [a] -> [a])
flip(:: (a -> b -> c) -> b -> a -> c)
floatDigits(:: RealFloat a => a -> Int)
floatProperFraction(:: (RealFloat a, Num b, RealFloat c) => c -> (b,a))
floatRadix(:: RealFloat a => a -> Integer)
floatRange(:: RealFloat a => a -> (Int,Int))
floatToRational(:: Float -> Rational)
floor(:: (RealFrac a, Integral b) => a -> b)
fmap(:: Functor a => (b -> c) -> a b -> a c)
foldl(:: (a -> b -> a) -> a -> [b] -> a)
foldl1(:: (a -> a -> a) -> [a] -> a)
foldr(:: (a -> b -> b) -> b -> [a] -> b)
foldr1(:: (a -> a -> a) -> [a] -> a)
fromDouble(:: Fractional a => Double -> a)
fromEnum(:: Enum a => a -> Int)
fromInt(:: Num a => Int -> a)
fromInteger(:: Num a => Integer -> a)
fromIntegral(:: (Integral a, Num b) => a -> b)
fromObj(:: Obj -> a)
fromRational(:: Fractional a => Rational -> a)
fst(:: (a,b) -> a)
gcd(:: Integral a => a -> a -> a)
getChar(:: IO Char)
getContents(:: IO String)
getLine(:: IO String)
head(:: [a] -> a)
hidding( module importation hiding)
id(:: a -> a)
if( conditional expresion)
import( module importation)
in( local definition )
inRange(:: Ix a => (a,a) -> a -> Bool)
index(:: Ix a => (a,a) -> a -> Int)
infix( non associative declaration)
infixl( lefy associative declaration)
infixr( right associative declaration)
init(:: [a] -> [a])
instance( instance declaration)
intToRatio(:: Integral a => Int -> Ratio a)
interact(:: (String -> String) -> IO ())
ioError(:: IOError -> IO a)
isAlpha(:: Char -> Bool)
isAlphaNum(:: Char -> Bool)
isDenormalized(:: RealFloat a => a -> Bool)
isDigit(:: Char -> Bool)
isEOFError(:: IOError -> Bool)
isHexDigit(:: Char -> Bool)
isIEEE(:: RealFloat a => a -> Bool)
isInfinite(:: RealFloat a => a -> Bool)
isLower(:: Char -> Bool)
isNaN(:: RealFloat a => a -> Bool)
isNegativeZero(:: RealFloat a => a -> Bool)
isOctDigit(:: Char -> Bool)
isSpace(:: Char -> Bool)
isUpper(:: Char -> Bool)
iterate(:: (a -> a) -> a -> [a])
last(:: [a] -> a)
lcm(:: Integral a => a -> a -> a)
length(:: [a] -> Int)
let( local definition)
lex(:: ReadS String)
lexDigits(:: ReadS String)
lexLitChar(:: ReadS String)
lexmatch(:: Eq a => [a] -> [a] -> ([a],[a]))
lines(:: String -> [String])
log(:: Floating a => a -> a)
logBase(:: Floating a => a -> a -> a)
lookup(:: Eq a => a -> [(a,b)] -> Maybe b)
loop(:: [IOResult] -> IOFinished a)
map(:: (a -> b) -> [a] -> [b])
mapM(:: Monad a => (b -> a c) -> [b] -> a [c])
mapM_(:: Monad a => (b -> a c) -> [b] -> a ())
max(:: Ord a => a -> a -> a)
maxBound(:: Bounded a => a)
maximum(:: Ord a => [a] -> a)
maybe(:: a -> (b -> a) -> Maybe b -> a)
min(:: Ord a => a -> a -> a)
minBound(:: Bounded a => a)
minimum(:: Ord a => [a] -> a)
mod(:: Integral a => a -> a -> a)
module( module definition)
negate(:: Num a => a -> a)
newtype( newtype definition )
nonnull(:: (Char -> Bool) -> ReadS String)
not(:: Bool -> Bool)
notElem(:: Eq a => a -> [a] -> Bool)
null(:: [a] -> Bool)
numerator(:: Integral a => Ratio a -> a)
odd(:: Integral a => a -> Bool)
of(case of selection)
or(:: [Bool] -> Bool)
otherwise(:: Bool)
pi(:: Floating a => a)
pred(:: Enum a => a -> a)
print(:: Show a => a -> IO ())
product(:: Num a => [a] -> a)
properFraction(:: (RealFrac a, Integral b) => a -> (b,a))
protectEsc(:: (Char -> Bool) -> ([Char] -> a) -> [Char] -> a)
putChar(:: Char -> IO ())
putStr(:: String -> IO ())
putStrLn(:: String -> IO ())
qualified ( qualified module importation )
quot(:: Integral a => a -> a -> a)
quotRem(:: Integral a => a -> a -> (a,a))
range(:: Ix a => (a,a) -> [a])
rangeSize(:: Ix a => (a,a) -> Int)
rationalToDouble(:: Rational -> Double)
rationalToFloat(:: Rational -> Float)
rationalToRealFloat(:: RealFloat a => Ratio Integer -> a)
read(:: Read a => String -> a)
readDec(:: Integral a => ReadS a)
readField(:: Read a => String -> ReadS a)
readFile(:: FilePath -> IO String)
readFloat(:: RealFrac a => ReadS a)
readHex(:: Integral a => ReadS a)
readIO(:: Read a => String -> IO a)
readInt(:: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a)
readList(:: Read a => ReadS [a])
readLitChar(:: ReadS Char)
readLn(:: Read a => IO a)
readOct(:: Integral a => ReadS a)
readParen(:: Bool -> ReadS a -> ReadS a)
readSigned(:: Real a => ReadS a -> ReadS a)
reads(:: Read a => ReadS a)
readsPrec(:: Read a => Int -> ReadS a)
realFloatToRational(:: RealFloat a => a -> Ratio Integer)
realToFrac(:: (Real a, Fractional b) => a -> b)
recip(:: Fractional a => a -> a)
reduce(:: Integral a => a -> a -> Ratio a)
rem(:: Integral a => a -> a -> a)
repeat(:: a -> [a])
replicate(:: Int -> a -> [a])
return(:: Monad a => b -> a b)
reverse(:: [a] -> [a])
round(:: (RealFrac a, Integral b) => a -> b)
scaleFloat(:: RealFloat a => Int -> a -> a)
scanl(:: (a -> b -> a) -> a -> [b] -> [a])
scanl1(:: (a -> a -> a) -> [a] -> [a])
scanr(:: (a -> b -> b) -> b -> [a] -> [b])
scanr1(:: (a -> a -> a) -> [a] -> [a])
seq(:: a -> b -> b)
sequence(:: Monad a => [a b] -> a [b])
sequence_(:: Monad a => [a b] -> a ())
show(:: Show a => a -> String)
showChar(:: Char -> ShowS)
showField(:: Show a => String -> a -> ShowS)
showInt(:: Integral a => a -> ShowS)
showList(:: Show a => [a] -> ShowS)
showLitChar(:: Char -> ShowS)
showParen(:: Bool -> ShowS -> ShowS)
showSigned(:: Real a => (a -> ShowS) -> Int -> a -> ShowS)
showString(:: String -> ShowS)
shows(:: Show a => a -> ShowS)
showsPrec(:: Show a => Int -> a -> ShowS)
significand(:: RealFloat a => a -> a)
signum(:: Num a => a -> a)
signumReal(:: (Num a, Num b, Ord a) => a -> b)
sin(:: Floating a => a -> a)
sinh(:: Floating a => a -> a)
snd(:: (a,b) -> b)
span(:: (a -> Bool) -> [a] -> ([a],[a]))
splitAt(:: Int -> [a] -> ([a],[a]))
sqrt(:: Floating a => a -> a)
subtract(:: Num a => a -> a -> a)
succ(:: Enum a => a -> a)
sum(:: Num a => [a] -> a)
tail(:: [a] -> [a])
take(:: Int -> [a] -> [a])
takeWhile(:: (a -> Bool) -> [a] -> [a])
tan(:: Floating a => a -> a)
tanh(:: Floating a => a -> a)
then( conditional expresion )
threadToIOResult(:: IO a -> IOResult)
toEnum(:: Enum a => Int -> a)
toInt(:: Integral a => a -> Int)
toInteger(:: Integral a => a -> Integer)
toObj(:: a -> Obj)
toRational(:: Real a => a -> Rational)
truncate(:: (RealFrac a, Integral b) => a -> b)
type( type synonym definition)
uncurry(:: (a -> b -> c) -> (a,b) -> c)
undefined(:: a)
unlines(:: [String] -> String)
unsafeCoerce(:: a -> b)
unsafeIndex(:: Ix a => (a,a) -> a -> Int)
unsafeRangeSize(:: Ix a => (a,a) -> Int)
until(:: (a -> Bool) -> (a -> a) -> a -> a)
unwords(:: [String] -> String)
unzip(:: [(a,b)] -> ([a],[b]))
unzip3(:: [(a,b,c)] -> ([a],[b],[c]))
userError(:: String -> IOError)
where( local definition)
words(:: String -> [String])
writeFile(:: FilePath -> String -> IO ())
zip(:: [a] -> [b] -> [(a,b)])
zip3(:: [a] -> [b] -> [c] -> [(a,b,c)])
zipWith(:: (a -> b -> c) -> [a] -> [b] -> [c])
zipWith3(:: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d])
|( data type definition or list comprehension)
||(:: Bool -> Bool -> Bool)
